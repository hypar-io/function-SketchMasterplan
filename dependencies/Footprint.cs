//----------------------
// <auto-generated>
//     Generated using the NJsonSchema v10.1.21.0 (Newtonsoft.Json v12.0.0.0) (http://NJsonSchema.org)
// </auto-generated>
//----------------------
using Elements;
using Elements.GeoJSON;
using Elements.Geometry;
using Elements.Geometry.Solids;
using Elements.Spatial;
using Elements.Validators;
using Elements.Serialization.JSON;
using System;
using System.Collections.Generic;
using System.Linq;
using Line = Elements.Geometry.Line;
using Polygon = Elements.Geometry.Polygon;
using Newtonsoft.Json;

namespace Elements
{
    public partial class Footprint : GeometricElement
    {
        [JsonProperty("Building Name")]
        public string BuildingName { get; set; } = null;

        [JsonProperty("Mass Name")]
        public string MassName { get; set; } = null;

        [JsonProperty("Number of Levels")]
        public int NumberOfLevels { get; set; } = 1;

        [JsonProperty("Footprint Shape")]
        public Polygon FootprintShape { get; set; }

        public Envelope Envelope { get; set; }

        public static Material UnsetMaterial => new Material((1, 1, 1, 0.75), 0, 0, false, null, true, false, null, false, new Guid("03befb1c-b5bb-43a1-9ceb-9a7e458e7068"), "Unset");
        public Footprint(Polygon p, List<double> levelHeights) : base(new Transform(), UnsetMaterial, new Representation(new List<SolidOperation>()))
        {
            this.BuildingLevels = levelHeights;
            this.LevelElements = new List<Element>();
            this.Boundary = p;
            this.FootprintShape = p;
            this.Area = p.Area();
            this.SetLevels(1, 1);
        }

        [JsonProperty("Starting Level")]

        public int StartingLevel { get; set; } = 1;

        [JsonIgnore]
        public bool StartingLevelWasSet = false;

        [JsonProperty("Last Level")]
        public int LastLevel
        {
            get
            {
                return this.StartingLevel + NumberOfLevels - 1;
            }
            set
            {
                this.NumberOfLevels = value - StartingLevel + 1;
            }
        }

        public double BaseElevation { get; set; } = 0;

        [JsonProperty("Building Levels")]
        public List<double> BuildingLevels { get; set; } = new List<double>();

        [JsonIgnore]
        private Dictionary<int, List<Extrude>> PerLevelExtrudes = new Dictionary<int, List<Extrude>>();

        public void UpdateLevelHeights()
        {
            this.SetLevels(this.StartingLevel, this.NumberOfLevels);
        }
        public void SetLevels(int startingLevel, int numLevels)
        {
            this.PerLevelExtrudes.Clear();
            this.StartingLevel = startingLevel;
            this.NumberOfLevels = numLevels;
            var baseElevation = 0.0;
            for (int i = 1; i < this.StartingLevel; i++)
            {
                var index = i - 1;
                if (index >= BuildingLevels.Count)
                {
                    index = BuildingLevels.Count - 1;
                }
                baseElevation += BuildingLevels[index];
            }
            var sumHeight = 0.0;
            for (int i = this.StartingLevel; i <= this.LastLevel; i++)
            {
                var index = i - 1;
                if (index < 0)
                {
                    index = 0;
                }
                if (index >= BuildingLevels.Count)
                {
                    index = BuildingLevels.Count - 1;
                }
                var extrude = new Extrude(this.FootprintShape.TransformedPolygon(new Transform(0, 0, sumHeight + ExtrudeSeparation)), BuildingLevels[index] - 2 * ExtrudeSeparation, Vector3.ZAxis, false);
                this.PerLevelExtrudes[i] = new List<Extrude> { extrude };
                sumHeight += BuildingLevels[index];
            }
            this.BaseElevation = baseElevation;
            this.Transform = new Transform(0, 0, baseElevation);
            this.Height = baseElevation + sumHeight;
            this.Area = this.FootprintShape.Area();
        }

        [JsonIgnore]
        private Dictionary<int, List<FootprintVoid>> PerLevelVoids = new Dictionary<int, List<FootprintVoid>>();

        public void AddVoid(FootprintVoid voidElement)
        {
            List<Profile> profiles = new List<Profile>();
            for (int i = voidElement.StartingLevel; i <= voidElement.LastLevel; i++)
            {
                if (!this.PerLevelExtrudes.ContainsKey(i))
                {
                    continue;
                }
                if (!PerLevelVoids.ContainsKey(i))
                {
                    PerLevelVoids[i] = new List<FootprintVoid>();
                }
                PerLevelVoids[i].Add(voidElement);

            }
        }

        private static double ExtrudeSeparation = 0.01;

        public void RefreshRepresentationAndGenerateLevelElements(Model model = null)
        {
            this.TotalArea = 0;
            var rep = new Representation();
            rep.SkipCSGUnion = true;
            var minElevation = double.MaxValue;
            foreach (var index in this.PerLevelExtrudes.Keys)
            {
                var levelName = $"Level {index:00}";
                var extrudes = this.PerLevelExtrudes[index];
                var level = new Level(extrudes.First().Profile.Perimeter.Vertices.First().Z - ExtrudeSeparation, name: levelName);
                LevelElements.Add(level);
                var hasVoids = this.PerLevelVoids.TryGetValue(index, out var voidElements);
                if (hasVoids)
                {
                    var existingExtrude = extrudes.First();
                    var allProfiles = extrudes.Select(p => p.Profile);
                    var elevation = existingExtrude.Profile.Perimeter.Vertices.First().Z;
                    if (elevation < minElevation)
                    {
                        minElevation = elevation;
                    }
                    var voidProfiles = voidElements.Select(v => new Profile(v.BoundaryProjected));
                    var differenceResult = Profile.Difference(allProfiles, voidProfiles).Select(p => p.Transformed(new Transform(0, 0, elevation)));
                    model?.AddElements(differenceResult.SelectMany(p => p.ToModelCurves(material: BuiltInMaterials.XAxis)));
                    foreach (var p in differenceResult)
                    {
                        rep.SolidOperations.Add(new Extrude(p, existingExtrude.Height, existingExtrude.Direction, existingExtrude.IsVoid));

                        var profileShifted = p.Transformed(new Transform(0, 0, -ExtrudeSeparation + BaseElevation));
                        var levelPerimeter = new LevelPerimeter(p.Area(), level.Elevation, profileShifted.Perimeter, name: levelName);
                        LevelElements.Add(levelPerimeter);

                        var profileProjected = profileShifted.Transformed(new Transform().Scaled(new Vector3(1, 1, 0)));
                        var newExtrude = new Extrude(profileProjected, existingExtrude.Height + 2 * ExtrudeSeparation, Vector3.ZAxis, false);
                        var levelVolume = new LevelVolume(profileProjected, newExtrude.Height, profileProjected.Area(), this.BuildingName, new Transform(0, 0, profileShifted.Perimeter.Vertices.First().Z), BuiltInMaterials.Glass, newExtrude, name: levelName);
                        levelVolume.AdditionalProperties["Footprint"] = this.Id;
                        LevelElements.Add(levelVolume);
                        this.TotalArea += levelVolume.Area;
                    }
                }
                else
                {
                    // this should only be one
                    foreach (var extrude in extrudes)
                    {
                        rep.SolidOperations.Add(extrude);

                        var profileShifted = extrude.Profile.Transformed(new Transform(0, 0, -ExtrudeSeparation));
                        var levelPerimeter = new LevelPerimeter(extrude.Profile.Area(), level.Elevation, profileShifted.Perimeter, name: levelName);
                        LevelElements.Add(levelPerimeter);

                        var profileProjected = profileShifted.Transformed(new Transform().Scaled(new Vector3(1, 1, 0)));
                        var newExtrude = new Extrude(profileProjected, extrude.Height + 2 * ExtrudeSeparation, Vector3.ZAxis, false);
                        var levelVolume = new LevelVolume(profileProjected, newExtrude.Height, profileProjected.Area(), this.BuildingName, new Transform(0, 0, profileShifted.Perimeter.Vertices.First().Z + BaseElevation), BuiltInMaterials.Glass, newExtrude, name: levelName);
                        levelVolume.AdditionalProperties["Footprint"] = this.Id;
                        LevelElements.Add(levelVolume);
                        this.TotalArea += levelVolume.Area;
                    }
                }
            }
            this.Representation = rep;
            var envelope = new Envelope()
            {
                Profile = this.FootprintShape,
                Height = this.Height - minElevation,
                Direction = Vector3.ZAxis,
                Representation = new Extrude(this.FootprintShape, this.Height - minElevation, Vector3.ZAxis, false),
                Rotation = 0,
                Transform = this.Transform,
                Material = BuiltInMaterials.Trans
            };
            envelope.AdditionalProperties["Footprint"] = this.Id;
            this.Envelope = envelope;
            foreach (var lv in this.LevelElements.OfType<LevelVolume>())
            {
                lv.AdditionalProperties["Envelope"] = this.Envelope.Id;
            }
        }

    }
}